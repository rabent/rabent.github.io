---
title: "웹 프로젝트 정리"
layout: post
date: 2025-06-09 15:32
tag:
- 잡설
description: 웹 프로젝트 구현 내용 정리
---  

## 서론  
진행중이던 프로젝트가 어느정도 목표하던 수준까지 마무리가 되고 추가로 해보고 싶었던 기능들을 구현해보려던 중, 무언가 다른걸 하기 전에 지금까지 했던 것을 정리하고 넘어가야겠다는 생각이 들었다.  
처음으로 진행해본 백엔드 프로젝트인 만큼 배우는게 굉장히 많았고, 다행히 페이스가 맞는 팀원을 만나 성장과 실습 중심으로 프로젝트를 원할히 진행할 수 있었다.  
프로젝트의 제목은 여행 웹 어플리케이션인 '함가자' 이지만, 기술적인 제목은 'Docker와 Nginx를 사용한 스프링 REST API의 CI/CD를 동반한 서버 배포 경험' 정도가 될 것 같다.  

## 프로젝트 개요

이번 포스팅은 2주 간 Spring Boot REST API 백엔드와 Vue.js 프론트엔드로 구성된 여행 계획 웹 애플리케이션을 개발하고 배포한 경험을 정리한 글입니다.  
프로젝트 시작 전, 기능 구현도 분명 배울 것이 있고 중요한 파트지만 기능이 많으면 한정된 프로젝트 기간 내에 비슷비슷한 CRUD를 구현하다 시간을 많이 소비할 것 같다 판단했습니다.  
따라서 본 프로젝트는 기능을 축소하고, 대신 실무에서 많이 사용되는 툴들이 어떤 방식으로 작동하고, 왜 그것을 사용하는지, 그리고 그것을 프로젝트에 어떻게 적용하는지를 고민하고 직접 사용해보는 것에 중점을 두었습니다.  
본 프로젝트에서 메인 프로그래머로써 담당한 파트인 **Docker를 통한 환경 격리**, **Nginx 리버스 프록시 구성**, **멀티 컨테이너 배포**, **Github Action을 사용한 CI/CD**, **JPA를 사용한 백엔드 MVC 구현**, **레이어 별 테스트 코드 및 통합 테스트 구성**까지 실무에서 자주 사용되는 기술들을 공부하고, 적용해본 경험을 작성하겠습니다.  

### 기술 스택  
- **Backend**: Spring Boot 3.4.5, Spring Security, JPA, OpenAI API  
- **Frontend**: Vue.js 3, Vue Router, Nginx  
- **Database**: MySQL (Production), H2 (Development)  
- **Infrastructure**: Docker, Docker Compose, Nginx, Github Action  

## 1. Docker를 통한 환경 격리와 표준화

### 백엔드 Docker 설정

Docker와 Docker compose를 사용함으로써 **환경을 격리**하여 팀원과의 개발 환경을, 그리고 개발 환경과 운영 환경을 일치시켜 안정적인 개발과 운영이 가능했습니다. 또한 이미지만 서버에 올려 **서버 배포 절차를 간소화**하며, 백과 프론트의 **빌드 및 실행을 자동화**하는 효과를 얻을 수 있었습니다.

<details>
<summary>Docker를 적용하게 된 계기(클릭 시 펼치기)</summary>
<div markdown="1">  
Docker를 적용하게 된 계기는 서버를 살 돈이 부족한 것이었습니다. 프로젝트 시작 전부터 AWS 서버에 9개 가량의 스프링 인스턴스를 띄우고 Nginx를 이용하여 로드밸런싱을 구축한 구조를 염두에 뒀습니다. 해당 구조와 Jmeter 등의 테스트 툴을 이용하여 로드밸런싱, 멀티스레딩, 기타 DB 최적화 등을 하나씩 적용하며 어느 정도의 차이가 나는지를 수치화 하는 그림을 그리고 있었습니다.  
하지만 이러한 환경을 위해서는 프리 티어 서버로는 도저히 불가능했고, 대신 Docker의 컨테이너를 사용하면 로컬에서 비슷한 효과를 낼 수 있다는 사실을 알게 되었습니다.  
따라서 서버에는 CI/CD 경험과 컨테이너 배포 경험을 위해 인스턴스 하나만을 배포하고, 기존의 테스트는 Docker를 사용하는 것으로 계획을 변경했습니다.  
개발 도중 Vue를 빌드한 후 Nginx를 켜고 스프링 서버를 키는 일련의 과정이 반복되자(어디까지 핫 리로딩이 되는 지가 모호하여 안정성을 위해), 어차피 Docker를 사용할거면 일찌감치 적용해서 빌드 자동화 등의 수혜를 보자는 생각이 들어 적용하게 되었습니다. 
</div>
</details>

```dockerfile
# 빌드 단계
FROM openjdk:17-jdk-slim as build

WORKDIR /app

# 그래들 파일 복사
COPY gradlew .
COPY gradle gradle
COPY build.gradle .
COPY settings.gradle .
# 운영체제 차이로 gradlew 파일을 못찾는 문제를 해결하기 위해 dos2unix install
RUN apt-get update && apt-get install -y dos2unix && dos2unix gradlew
RUN chmod +x ./gradlew
RUN ./gradlew dependencies --no-daemon

COPY src src

RUN ./gradlew bootJar --no-daemon


FROM openjdk:17-jdk-slim

WORKDIR /app

# 빌드 단계에서 생성된 jar 파일 복사
COPY --from=build /app/build/libs/*.jar app.jar

# 메모리 및 GC 최적화
ENV JAVA_OPTS="-Xms128m -Xmx256m -XX:+UseG1GC -XX:MaxGCPauseMillis=200"

# 애플리케이션 프로필은 환경 변수로 지정
ENV SPRING_PROFILES_ACTIVE=default

ENV SERVER_PORT=8080

ENV DB_HOST=host.docker.internal
ENV DB_PORT=3306
ENV DB_NAME=ssafytrip
ENV DB_USERNAME=ssafy
ENV DB_PASSWORD=ssafy

EXPOSE ${SERVER_PORT}

# 시작 명령어
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar --spring.profiles.active=$SPRING_PROFILES_ACTIVE --server.port=$SERVER_PORT"]
```  

#### 주요 포인트:
- **멀티 스테이지 빌드**: 빌드 도구와 소스코드가 포함된 무거운 이미지와 실행만을 위한 경량 이미지 분리
- **의존성 캐싱**: Gradle 의존성을 먼저 다운로드하여 Docker 레이어 캐싱 활용
- **환경 변수**: 개발/운영 환경 분리를 위한 유연한 설정
- **메모리 최적화**: JVM 힙 크기 제한으로 컨테이너 환경에 최적화

### 프론트엔드 Docker 설정

Vue.js 애플리케이션도 동일하게 멀티 스테이지 빌드를 적용했고, Docker에서 제공하는 nginx alpine 경량 이미지를 사용하여 로컬에서 nginx가 필요하지 않도록 구현했습니다.

```dockerfile
# 빌드 단계
FROM node:18 as build-stage
WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .
RUN npm run build

# 프로덕션 단계
FROM nginx:alpine as production-stage
RUN rm -rf /etc/nginx/conf.d/*

COPY --from=build-stage /app/dist /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

### Docker compose 설정  

Docker compose는 3개의 파일로 환경을 각각 개발, 배포, 테스트(멀티 인스턴스)로 구분하여 작성했습니다. .env 파일로 중요한 정보를 환경변수로 유연하게 사용할 수 있도록 구현하였고, 배포 환경에서는 이미지를 빌드하여 결과물만 Docker hub로 전송할 수 있도록 구현했습니다. 

<details>
<summary>개발 환경 docker-compose</summary>
<div markdown="1">  

```  
services:
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile.test
    container_name: spring-backend
    volumes:
      - gradle-cache:/root/.gradle  # Gradle 캐시 볼륨
    restart: always
    networks:
      - app-network
    environment:
      - SPRING_PROFILES_ACTIVE=local
      - JWT_KEY=${JWT_KEY}
      - API_KEY=${API_KEY}
    env_file:
      - .env

  frontend:
    build:
      context: ./frontend/final-front
    container_name: vue-frontend
    restart: always
    ports:
      - "8080:8080"  # 외부 8080 포트를 컨테이너 80 포트에 매핑
    volumes:
      - ./frontend/final-front/nginx.conf:/etc/nginx/nginx.conf # Nginx 설정 마운트
    depends_on:
      - backend
    networks:
      - app-network

volumes:
  gradle-cache:  # 도커 관리 볼륨 정의

networks:
  app-network:
    driver: bridge
```  
</div>
</details>  

<details>
<summary>배포 환경 docker-compose</summary>
<div markdown="1">  

```  
services:
  backend:
    build:
      context: ./Backend
      dockerfile: Dockerfile.test
    image: rabent0207/final-penet-backend:latest
    container_name: spring-backend
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - SERVER_PORT=8080
      - DB_HOST=172.31.45.114
      - DB_PORT=3306
      - DB_NAME=ssafy
      - DB_USERNAME=ssafy
      - DB_PASSWORD=ssafy
      - JWT_KEY=${JWT_KEY}
      - API_KEY=${API_KEY}
    env_file:
      - .env
    volumes:
      - gradle-cache:/root/.gradle  # Gradle 캐시 볼륨
    restart: always
    networks:
      - app-network
      # 필요한 환경변수 추가 (DB 설정 등)

  frontend:
    build:
      context: ./Frontend/final-front
    image: rabent0207/final-penet-frontend:latest
    container_name: vue-frontend
    restart: always
    ports:
      - "8080:8080"  # 외부 8080 포트를 컨테이너 80 포트에 매핑
    volumes:
      - ./Frontend/final-front/nginx.conf:/etc/nginx/nginx.conf # Nginx 설정 마운트
    depends_on:
      - backend
    networks:
      - app-network

volumes:
  gradle-cache:  # 도커 관리 볼륨 정의

networks:
  app-network:
    driver: bridge
```
</div>
</details>  

<details>
<summary>테스트 환경 docker-compose</summary>
<div markdown="1">  

```  
version: '3'

services:
  app-build:
    build:
      context: ./backend
      dockerfile: Dockerfile.test
    image: my-spring-app:latest
    profiles:
      - build-only  # 이 서비스는 기본적으로 시작되지 않음

  # 앱 1
  app1:
    image: my-spring-app:latest
    container_name: spring-app1
    ports:
      - "8081:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - JAVA_OPTS=-Xms128m -Xmx256m
    deploy:
      resources:
        limits:
          memory: 600M
          cpus: '0.5'
    networks:
      - spring-network

  # 앱 2
  app2:
    image: my-spring-app:latest
    container_name: spring-app2
    ports:
      - "8082:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - JAVA_OPTS=-Xms128m -Xmx256m
    deploy:
      resources:
        limits:
          memory: 600M
          cpus: '0.5'
    networks:
      - spring-network

  # 앱 3
  app3:
    image: my-spring-app:latest
    container_name: spring-app3
    ports:
      - "8083:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - JAVA_OPTS=-Xms128m -Xmx256m
    deploy:
      resources:
        limits:
          memory: 600M
          cpus: '0.5'
    networks:
      - spring-network

  # 앱 4
  app4:
    image: my-spring-app:latest
    container_name: spring-app4
    ports:
      - "8084:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - JAVA_OPTS=-Xms128m -Xmx256m
    deploy:
      resources:
        limits:
          memory: 600M
          cpus: '0.5'
    networks:
      - spring-network

  # 앱 5
  app5:
    image: my-spring-app:latest
    container_name: spring-app5
    ports:
      - "8085:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - JAVA_OPTS=-Xms128m -Xmx256m
    deploy:
      resources:
        limits:
          memory: 600M
          cpus: '0.5'
    networks:
      - spring-network

  # 앱 6
  app6:
    image: my-spring-app:latest
    container_name: spring-app6
    ports:
      - "8086:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - JAVA_OPTS=-Xms128m -Xmx256m
    deploy:
      resources:
        limits:
          memory: 600M
          cpus: '0.5'
    networks:
      - spring-network

  # 앱 7
  app7:
    image: my-spring-app:latest
    container_name: spring-app7
    ports:
      - "8087:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - JAVA_OPTS=-Xms128m -Xmx256m
    deploy:
      resources:
        limits:
          memory: 600M
          cpus: '0.5'
    networks:
      - spring-network

  # 앱 8
  app8:
    image: my-spring-app:latest
    container_name: spring-app8
    ports:
      - "8088:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - JAVA_OPTS=-Xms128m -Xmx256m
    deploy:
      resources:
        limits:
          memory: 600M
          cpus: '0.5'
    networks:
      - spring-network

  # 앱 9
  app9:
    image: my-spring-app:latest
    container_name: spring-app9
    ports:
      - "8089:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - JAVA_OPTS=-Xms128m -Xmx256m
    deploy:
      resources:
        limits:
          memory: 600M
          cpus: '0.5'
    networks:
      - spring-network

  frontend:
    build:
      context: ./frontend/final-front
    container_name: vue-frontend
    restart: always
    ports:
      - "8080:8080"
    volumes:
      - ./frontend/final-front/nginx.test.conf:/etc/nginx/nginx.conf # Nginx 설정 마운트
    depends_on:
      - app1
      - app2
      - app3
      - app4
      - app5
      - app6
      - app7
      - app8
      - app9
    networks:
      - spring-network

networks:
  spring-network:
    driver: bridge
```

</div>
</details>  

## 2. Nginx 리버스 프록시 구성

### SPA 라우팅과 API 프록시 설정

추후 있을 테스트의 로드밸런싱을 위해, 그리고 당장은 CORS 문제를 해결하고 정적 파일 서빙에서의 이점을 얻기 위해 Nginx를 리버스 프록시로 활용했습니다.

```nginx
server {
    listen 8080;
    server_name localhost;
    root /usr/share/nginx/html;
    index index.html;

    # 정적 에셋 처리
    location /assets/ {
        try_files $uri =404;
    }

    # API 프록시 - Spring 서버로 전달
    location /api/ {
        proxy_pass http://backend:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Vue 라우팅을 위한 설정
    location / {
        try_files $uri $uri/ /index.html;
    }
}
```

#### 핵심 학습 포인트:
- **API 라우팅**: `/api/` 경로는 백엔드로, 나머지는 Vue 앱으로 분기
- **SPA 지원**: `try_files`를 통한 클라이언트 사이드 라우팅 지원
- **프록시 헤더**: 원본 클라이언트 정보 전달을 위한 헤더 설정

### 로드 밸런싱 실험

추후 성능 테스트를 위해 다중 백엔드 인스턴스와 로드 밸런싱을 구현하였고, 로컬에서 컨테이너로 띄웠을 때 JWT를 사용했기에 로그인 등의 기능이 인스턴스를 오가며 잘 작동하는 것을 확인했습니다.

```nginx
upstream spring_apps {
    server spring-app1:8080;
    server spring-app2:8080;
    server spring-app3:8080;
    # ... 최대 9개 인스턴스
}

location /api/ {
    proxy_pass http://spring_apps;
    # 프록시 헤더 설정...
}
```

## 5. 환경별 설정 관리

### Spring Boot 프로파일 설정

개발과 운영 환경의 차이점을 효과적으로 관리하기 위해 Spring Boot의 프로파일 기능을 활용했습니다.

- **local**: H2 데이터베이스, 개발용 설정
- **prod**: MySQL 데이터베이스, 운영용 설정

### 환경 변수를 통한 설정 외부화

민감한 정보들은 환경 변수로 분리하여 보안을 강화했습니다.

```properties
# application-prod.properties
spring.datasource.url=jdbc:mysql://${DB_HOST}:${DB_PORT}/${DB_NAME}
spring.datasource.username=${DB_USERNAME}
spring.datasource.password=${DB_PASSWORD}
jwt.secret=${JWT_KEY}
spring.ai.openai.api-key=${API_KEY}
```

## 6. 트러블슈팅 경험

### 1. 컨테이너 간 통신 문제
**문제**: 프론트엔드에서 백엔드 API 호출 실패  
**해결**: Docker 네트워크 내에서는 서비스명으로 통신해야 함을 학습

### 2. Nginx 설정 마운팅 이슈
**문제**: Nginx 설정 변경이 반영되지 않음  
**해결**: 볼륨 마운팅을 통한 설정 파일 동적 변경 적용

### 3. 메모리 부족 문제
**문제**: 다중 백엔드 인스턴스 실행 시 메모리 부족  
**해결**: JVM 힙 크기 조정과 Docker 리소스 제한 설정

## 7. 성능 최적화 경험

### Gradle 캐시 최적화
Docker 볼륨을 활용해 Gradle 의존성 캐시를 유지하여 빌드 시간을 단축했습니다.

### 이미지 크기 최적화
- Alpine Linux 베이스 이미지 사용
- 멀티 스테이지 빌드로 불필요한 빌드 도구 제거
- .dockerignore를 통한 불필요한 파일 제외

## 마무리

이번 프로젝트를 통해 단순한 웹 애플리케이션 개발을 넘어서 **실제 서비스 배포와 운영에 필요한 기술들**을 직접 경험해볼 수 있었습니다. 특히 다음과 같은 점들이 인상 깊었습니다.

### 핵심 학습 내용:
1. **환경 일관성**: Docker를 통한 개발/운영 환경 표준화
2. **서비스 분리**: 마이크로서비스 아키텍처의 기초 경험
3. **네트워크 이해**: 컨테이너 간 통신과 프록시 설정
4. **운영 고려사항**: 모니터링, 로그 관리, 리소스 최적화

### 향후 개선 사항:
- **CI/CD 파이프라인**: GitHub Actions를 통한 자동화 배포
- **모니터링**: Prometheus + Grafana 도입
- **보안 강화**: SSL 인증서 적용, 보안 헤더 설정
- **스케일링**: Kubernetes를 활용한 컨테이너 오케스트레이션

백엔드 개발자로서 단순히 API를 만드는 것을 넘어서, **전체 시스템의 아키텍처를 이해하고 실제 서비스로 배포하는 전 과정**을 경험할 수 있었던 의미 있는 프로젝트였습니다.

---

*프로젝트 저장소: [GitHub 링크 추가 예정]*  
*배포 URL: [배포 주소 추가 예정]*
