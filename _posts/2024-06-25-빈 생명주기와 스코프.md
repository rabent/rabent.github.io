---
title: "스프링 입문-빈 생명주기와 스코프"
layout: post
date: 2024-06-25 16:55
tag:
- Spring
- JAVA
description: 스프링 입문 강의 핵심 정리
---  

# 빈의 생명 주기 콜백  
스프링 컨테이너에 올라간 빈은 기본적으로 의존관계 주입이 완료되어야 제대로 된 기능을 수행할 수 있는 상태가 된다. 하지만 객체 중 초기화나 적절한 종료 작업이 필요한 객체가 있다면 어떻게 해야 할까?  
이를 위해 스프링에서는 객체의 의존관계 주입이 완료된 후, 그리고 객체의 소멸 직전에 작동하는 여러 **콜백 기능**을 제공한다. 이러한 콜백 기능에는 3가지가 있다.  

## InitializingBean, DisposableBean  
{% highlight java %}
public class NetworkClient implements InitializingBean, DisposableBean {
    @Override
    public void afterPropertiesSet() throws Exception {
        connect();
        call("초기화 연결 메시지");
    }
    @Override
    public void destroy() throws Exception {
        disConnect();
    }
}
{% endhighlight %}  
위와 같이 **InitializingBean, DisposableBean** 인터페이스를 구현한 클래스는 객체의 의존관계 주입 이후와 소멸 직전에 발동하는 afterPropertiesSet(), destroy() 메서드를 제공한다.  
이 방법은 스프링 초창기에 나온 방법으로 스프링에 코드가 종속되고 외부 라이브러리에 적용이 불가능하며 초기화, 소멸 메서드의 이름을 변경하는 것이 불가능한 등 여러 단점이 있어 지금은 거의 사용되지 않는다.  

## 빈 초기화, 소멸 메서드 지정  
설정 정보에서 파라미터를 넣어 빈의 초기화와 종료 메서드를 지정할 수도 있다.  
{% highlight java %}
@Configuration
static class LifeCycleConfig {
   @Bean(initMethod = "init", destroyMethod = "close")
    public NetworkClient networkClient() {
        NetworkClient networkClient = new NetworkClient();
        networkClient.setUrl("http://hello-spring.dev");
        return networkClient;
   }
}
{% endhighlight %}  
위와 같이 **설정 정보에서 지정**하면 메서드 이름을 자유롭게 지정할 수 있고, 외부 라이브러리에서도 사용 가능하며 스프링에 종속되지 않는 등 인터페이스 구현 방식의 단점을 모두 해결한 것을 볼 수 있다.  
하지만 이보다 더 편한 방법이 있는데 애너테이션을 이용하는 것이다.  

## @PostConstruct, @PreDestroy  
{% highlight java %}
@PostConstruct
public void init() {
    System.out.println("NetworkClient.init");
    connect();
    call("초기화 연결 메시지");
}
@PreDestroy
public void close() {
    System.out.println("NetworkClient.close");
    disConnect();
}
{% endhighlight %}  
위와 같이 초기화, 소멸 메서드로 지정하고 싶은 메서드 위에 **@PostConstruct, @PreDestroy** 애너테이션을 달아주면 초기화, 소멸 메서드로써 기능한다.  
이 방법은 최신 스프링에서 가장 권장하는 방법이고, 편할 뿐더러 스프링이 아닌 자바 표준이기 때문에 다른 컨테이너에서도 작동한다. 콜백 기능을 사용해야 한다면 애너테이션 방식을 사용하자.  

# 빈 스코프  
우리가 스프링 빈이 싱글톤을 보장한다고 배웠던 것은 스프링 빈이 기본적으로 **싱글톤 스코프**로 생성되기 때문이다. 스코프는 번역 그대로 **빈이 존재할 수 있는 범위**를 뜻하는데, 기본적으로 싱글톤, 프로토타입 스코프가 있고 웹 관련으로는 request, session, application 스코프가 있다.  
{% highlight java %}
@Scope("prototype")
@Component
public class HelloBean {}
{% endhighlight %}  
스코프는 위와 같이 애너테이션을 통해 지정한다. 스코프들 중 우리가 배우지 않았던 프로토타입 스코프와 웹 스코프 중 가장 기본적인 request 스코프를 알아보자.  

## 프로토타입 스코프  

![프로토타입](/assets/img/프로토타입%20빈.png)  

위 그림과 같이 프로토타입 빈은 **싱글톤을 보장하지 않는다**. 클라이언트가 빈을 요청하면 매번 새로운 객체를 생성하여 클라이언트에게 전달한다.  
프로토타입 빈은 객체의 생성, 의존관계 주입, 초기화 까지만 책임을 진다. 그 이후의 책임은 클라이언트에게 있다. 따라서 @PreDestroy와 같은 종료 메서드도 작동하지 않는다.  
프로토타입 빈 자체는 기능대로 작동한다. 하지만 싱글톤 빈과 프로토타입 빈을 같이 사용한다면 예상치 못한 문제가 생길 수도 있다.  
{% highlight java %}
    @Test
    void singletonClientUsePrototype() {
        AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(ClientBean.class,PrototypeBean.class);
        ClientBean clientBean1 = ac.getBean(ClientBean.class);
        int count1 = clientBean1.logic();
        Assertions.assertThat(count1).isEqualTo(1);
        ClientBean clientBean2 = ac.getBean(ClientBean.class);
        int count2 = clientBean2.logic();
        Assertions.assertThat(count2).isEqualTo(1);
    }
    static class ClientBean {
        private final PrototypeBean prototypeBean;
        @Autowired
        public ClientBean(PrototypeBean prototypeBean) {
        this.prototypeBean = prototypeBean;
        }
        public int logic() {
            prototypeBean.addCount();
            int count = prototypeBean.getCount();
            return count;
        }
    }
    @Scope("prototype")
    static class PrototypeBean {
        private int count=0;
        public void addCount() {
            count++;
        }
        public int getCount() {
            return count;
        }

        @PostConstruct
        public void init() {
            System.out.println("PrototypeBean.init" + this);
        }
        @PreDestroy
        public void destroy() {
            System.out.println("PrototypeBean.destroy");
        }
    }
{% endhighlight %}  
위 코드는 싱글톤 빈이 프로토타입 빈을 주입받아 작동하는 코드이다. 프로토타입 빈을 사용하였으니 매번 객체를 새로 생성받아 작동하는 것을 기대했겠지만, 실제로는 그렇게 작동하지 않는다.  
싱글톤 빈이 처음 객체를 생성하여 컨테이너에 올라갈 때, 그 때 프로토타입 빈을 같이 생성하여 주입받은 뒤 해당 객체를 계속해서 사용한다. 따라서 clientBean1과 clientBean2의 프로토타입 빈은 모두 같은 객체이다.  
이러한 문제를 해결하기 위해선 Provider과 DL에 대해 알아야 한다.  
