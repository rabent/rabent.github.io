---
title: "스프링 MVC-스프링 MVC 웹 구축"
layout: post
date: 2024-07-18 16:30
tag:
- Spring
- JAVA
description: 스프링 입문 강의 핵심 정리
---  

# 요구사항  
지금까지 배운 스프링 MVC의 기능들로 간단한 웹 페이지를 구축해볼 것이다. 요구사항은 다음과 같다.  

**상품 도메인 모델**
- 상품 ID  
- 상품명  
- 가격  
- 수량    

**상품 관리 기능**
- 상품 목록  
- 상품 상세  
- 상품 등록  
- 상품 수정  

## 상품 도메인 코드  
{% highlight java %}
package hello.itemservice.domain.item;

import lombok.Data;

@Data
public class Item {
    Long id;
    String itemName;
    Integer price;
    int quantity;

    public Item() {
    }

    public Item(String itemName, Integer price, int quantity) {
        this.itemName = itemName;
        this.price = price;
        this.quantity = quantity;
    }
}
{% endhighlight %}  
요구사항대로 작성한 코드이다. 생성자는 기본 생성자와 파라미터를 입력받는 타입 두가지를 만들었다.  


## 상품 리포지토리 코드  
{% highlight java %}
@Repository
public class ItemRepository {
    static final Map<Long, Item> store=new HashMap<>();
    static Long sequence=0L;

    public Item save(Item item) {
        item.setId(++sequence);
        store.put(item.getId(), item);
        return item;
    }

    public Item findById(Long id) {
        return store.get(id);
    }

    public List<Item> findAll() {
        return new ArrayList<>(store.values());
    }

    public void update(Long itemId, Item updateParam) {
        Item findItem = findById(itemId);
        findItem.setItemName(updateParam.getItemName());
        findItem.setPrice(updateParam.getPrice());
        findItem.setQuantity(updateParam.getQuantity());
    }
    public void clearStore() {
        store.clear();
    }
}
{% endhighlight %}  
요구사항대로 구축한 리포지토리의 코드이다. 해쉬맵에 데이터를 저장하도록 했고 필요한 저장, 검색, 업데이트 기능이 구현되어있다. 이제 웹과 맵핑되어 리포지토리에 데이터를 저장하는 컨트롤러를 만들어야 한다.  
그 이전에 html을 동적으로 바꿔줄 타임리프에 대해 간단히 알아보자.  

# 타임리프  
{% highlight html %}  
<html xmlns:th="http://www.thymeleaf.org">
{% endhighlight %}  

**뷰 템플릿**인 타임리프는 기본적으로 위와 같이 선언하여 사용한다. 위와 같이 선언하고 동적으로 고쳐야할 부분에 'th:value=' 과 같이 붙여주면, 해당 부분이 모델에서 받은 데이터를 동적으로 페이지에 입력해준다.  
**필요한 부분만 동적으로 치환**하기 때문에 jsp 등과 달리 html 파일을 그대로 웹에서 출력해도 html이 깨지지 않는다. 따라서 서버를 띄우지 않아도 테스트가 용이한 장점이 있고, 이와 같이 html을 훼손하지 않기 때문에 **네츄럴 템플릿**이라고 불린다.  

{% highlight html %}  
<div class="row">
    <div class="col">
        <button class="btn btn-primary float-end"
            onclick="location.href='addForm.html'"
            type="button">상품 등록</button>
    </div>
</div> 
{% endhighlight %}  
우리가 동적으로 고쳐야 할 html이다. 기본 설정으로 정적인 리소스인 'addForm.html'을 띄우도록 되어있다.  

{% highlight html %}  
<div class="row">
    <div class="col">
        <button class="btn btn-primary float-end"
            onclick="location.href='addForm.html'"
            th:onclick="|location.href='@{/basic/items/add}'|"
            type="button">상품 등록</button>
    </div>
</div> 
{% endhighlight %}  
아래에 'th:onclick="|location.href='@{/basic/items/add}'|"' 한 줄만 추가하여 페이지를 동적으로 만들었다. 위와 같이 작성하면 서버 사이드에서 렌더링되면서 아래의 값으로 치환되는 방식이다.  

타임리프는 **url 링크**를 사용할 때엔 **'@{}'**와 같은 형식을 사용하므로 위와 같이 되었다.  
**'||'** 표시는 **리터럴 대체 문법**인데, 원래는 타임리프에서 문자와 표현식이 분리되어있기 때문에 String을 사용하듯이 'location.href='+'\'' 와 같이 불편하게 사용해야 했다. 하지만 리터럴 대체 문법을 사용하면 위에서 작성한 것과 같이 더하기 없이 편리하게 작성이 가능하다.  

{% highlight html %}  
<tr th:each="item : ${items}">
    <td><a href="item.html" th:href="@{/basic/items/{itemId}(itemId=${item.id})}" th:text="${item.id}">회원id</a></td>
    <td><a href="item.html" th:href="@{|/basic/items/${item.id}|}" th:text="${item.itemName}">상품명</a></td>
    <td th:text="${item.price}">10000</td>
    <td th:text="${item.quantity}">10</td>
</tr>
{% endhighlight %}  

상품 목록을 띄우는 파트이다. **'th:each='**를 사용하면 모델에 포함된 컬렉션 데이터에서 하나씩 뽑아서 출력할 수 있다. 위에선 모델의 items란 이름의 컬렉션에서 하나씩 뽑아 item이란 변수에 넣은 것을 볼 수 있다.  

타임리프에서 변수의 값을 조회하려면 '${}'와 같은 표현식을 사용한다. 타임리프 내부에서 선언된 변수나 모델에 포함된 데이터를 조회할 때 사용한다. 위에서는 ${items}로 모델의 데이터를 조회하였다.  

th:href="@{|/basic/items/${item.id}|}" 이 문장을 보면, **url 경로 표현식에서 변수를 사용**할 수 있음을 알 수 있다. 실제 웹에서는 item의 id가 들어간 동적인 url이 될 것이다.  

경로에 변수 뿐만 아니라 쿼리 파라미터도 사용이 가능한데, (itemId=${item.id}, query='test')와 같이 작성하면 변수 값을 url에 넣어줄 뿐만 아니라 **쿼리 파라미터도 작성**하여 입력해준다. 예를 들면 'http://localhost:8080/basic/items/1?query=test' 와 같은 링크가 될 것이다.  

html에서 action은 form 내부에서 데이터를 전송(submit) 했을 때 도착할 url을 의미하는데, 'th:action'과 같이 값을 넣지 않으면 현재 url에 그대로 데이터를 전송한다.  
현재 url에 그대로 데이터를 전송하고, 컨트롤러에서 @GetMapping, @PostMapping으로 같은 url을 메서드에 따라 다르게 받음으로써 하나의 url로 폼과 등록 처리를 동시에 깔끔하게 처리할 수 있다.  

# 컨트롤러 구현  
이제 html은 어느정도 구현이 됬으니, 웹과 맵핑할 **컨트롤러**를 만들어보자. html은 위에서 사용한 테크닉들로 모델에서 데이터를 적절히 받아 출력한다고 가정하고 넘어가겠다.  
{% highlight java %}  
@Controller
@RequestMapping("/basic/items")
@RequiredArgsConstructor
public class BasicItemController {
    private final ItemRepository itemRepository;
    @GetMapping
    public String items(Model model) {
        List<Item> items = itemRepository.findAll();
        model.addAttribute("items", items);
        return "basic/items";
    }
 /**
 * 테스트용 데이터 추가
 */
    @PostConstruct
    public void init() {
        itemRepository.save(new Item("testA", 10000, 10));
        itemRepository.save(new Item("testB", 20000, 20));
    }
}
{% endhighlight %}  
기본적인 상품목록 조회 기능만 있는 컨트롤러이다. 클래스 단에 @RequestMapping("/basic/items") 어노테이션을 달아 메서드들은 논리 경로만 맵핑하도록 하였다.  
뷰 템플릿인 타임리프를 사용하므로 return "basic/items"; 과 같이 String을 반환하면, resources/templates/basic/items.html 이라는 뷰를 렌더링하여 띄워줄 것이다.  
아래에는 테스트가 용이하게 하기 위해 기본적인 데이터를 입력해주었다.  

## 상품 상세  
{% highlight java %}  
    @GetMapping("/{itemId}")
    public String item(@PathVariable Long itemId, Model model) {
        Item item = itemRepository.findById(itemId);
        model.addAttribute("item", item);
        return "basic/item";
    }
{% endhighlight %}  

웹에서 상품명을 클릭했을 때, 상품 상세를 띄워주는 메서드이다.  
@PathVariable 어노테이션으로 url로부터 변수를 받아, 해당 id로 객체를 찾고 모델에 넣어 view에 넘겨주는 역할을 한다.  

## 상품 등록  
등록할 상품의 데이터는 POST-HTML Form 형식으로 메세지 바디에 쿼리 파라미터로 데이터가 들어온다고 가정하겠다.  
@RequestParam으로 쿼리 파라미터를 하나씩 받아 객체를 생성하는 방법도 있지만, 우리는 더욱 효율적인 방법을 이미 알고있다. 따라서 @ModelAttribute를 사용하여 구현하도록 하겠다.