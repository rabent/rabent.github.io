---
title: "스프링 MVC-스프링 MVC 요청과 응답"
layout: post
date: 2024-07-15 16:49
tag:
- Spring
- JAVA
description: 스프링 입문 강의 핵심 정리
---  

# 스프링의 로깅  
시작하기 전에 스프링에서 **로깅**을 어떻게 하는지에 대해 간단히 알아보고 가자. 기본적으로 스프링에서 로깅은 다음과 같이 사용한다.  
{% highlight java %}
private final Logger log = LoggerFactory.getLogger(getClass());

log.trace("trace log={}", name);
log.debug("debug log={}", name);
log.info(" info log={}", name);
log.warn(" warn log={}", name);
log.error("error log={}", name);
{% endhighlight %}  
위와 같이 LoggerFactory 클래스에서 getLogger() 메서드로 **Logger 객체**를 받아와 사용하는데, lombok의 **@Slf4j** 어노테이션을 사용하면 자동으로 log라는 이름의 Logger 객체를 생성해주므로 편리하게 사용할 수 있다.  
로깅은 위와 같이 5가지 단계로 나뉘는데, application.properties 파일에서 설정값을 변경하여 어느 단계의 로그부터 볼 것인지를 설정할 수 있다.  
이를 통해 개발 서버에서는 모든 로그를 보고, 운영 서버에서는 중요한 warn, error 로그부터 보는 등의 사용이 가능하다.  

# @RequestMapping  
우리는 지금까지 @RequestMapping 어노테이션을 통해 컨트롤러에 대한 접근을 맵핑했었다. 스프링에는 HTTP 메서드, PathVariable, 파라미터 등 여러 조건을 더해 매핑이 가능하다. 아래의 예시를 통해 하나씩 알아보자.  

## HTTP 메서드 매핑  
{% highlight java %}
/**
 * 편리한 축약 애노테이션 (코드보기)
 * @GetMapping
 * @PostMapping
 * @PutMapping
 * @DeleteMapping
 * @PatchMapping
 */
@GetMapping(value = "/mapping-get-v2")
public String mappingGetV2() {
    log.info("mapping-get-v2");
    return "ok";
}
{% endhighlight %}  
위와 같이 @RequestMapping 대신 원하는 **HTTP 메서드의 어노테이션**을 사용하면 해당 메서드로만 컨트롤러에 접근이 가능하도록 맵핑할 수 있다. 해당 메서드가 아닌 메서드로 접근하면 HTTP 405 상태메세지를 반환한다.  

## PathVariable 사용  
최근 HTTP API는 URI에 식별자를 넣는 스타일이 선호된다. 따라서 **PathVariable**을 사용하면 Request에서 따로 식별자를 파싱해오는 일 없이 손쉽게 식별자를 가져올 수 있다.  
{% highlight java %}
/**
 * PathVariable 사용 다중
 */
@GetMapping("/mapping/users/{userId}/orders/{orderId}")
public String mappingPath(@PathVariable String userId, @PathVariable Long
orderId) {
    log.info("mappingPath userId={}, orderId={}", userId, orderId);
    return "ok";
}
{% endhighlight %}  
PathVariable로 설정한 userId, orderId를 URI로부터 받아오는 코드이다.  

## 파라미터, 헤더, 미디어 타입  
HTTP 요청의 **파라미터, 헤더, 미디어 타입** 등의 조건으로도 맵핑이 가능하다. 내부 코드는 대부분 비슷하므로 어노테이션만 가지고 비교해보도록 하겠다.  
{% highlight java %}
@GetMapping(value = "/mapping-param", params = "mode=debug")
@GetMapping(value = "/mapping-header", headers = "mode=debug")
@PostMapping(value = "/mapping-consume", consumes = "application/json")
@PostMapping(value = "/mapping-produce", produces = "text/html")
{% endhighlight %}  
위의 두 개, 파라미터와 헤더 맵핑에 대해선 쉽게 이해할 수 있을 것이다. 하지만 아래의 미디어 타입 매핑 두 가지엔 큰 차이가 있다.  
위의 **consumes**를 사용하는 미디어 타입 맵핑은 **서버가 HTTP 요청을** 읽고 요청의 헤더에 있는 Content-Type이 맞지 않으면 HTTP 상태코드 415를 반환한다.  
하지만 아래의 **produces**를 사용하는 맵핑은 **클라이언트가 서버의 응답을** 받아들일 수 있는지를 HTTP 요청에 들어온 Accept 헤더를 읽고 판단한다.  
Accept 헤더에 해당하는 컨텐츠 타입이 없다면, 즉 클라이언트가 서버가 생산한 컨텐츠 타입을 받아들일 수 없다면 HTTP 상태코드 406을 반환한다.  

# 헤더 조회  
스프링에서 HTTP 요청의 헤더를 조회하는 데에는 여러 방법이 있다. 아래의 코드를 통해 알아보자.  
{% highlight java %}
@RequestMapping("/headers")
public String headers(HttpServletRequest request,
    HttpServletResponse response,
    HttpMethod httpMethod, //HTTP 메서드를 조회한다.
    Locale locale, //Locale(국가 등) 정보를 조회한다.
    @RequestHeader MultiValueMap<String, String> headerMap, //모든 헤더를 조회한다.
    @RequestHeader("host") String host, //특정 헤더를 조회한다.
    @CookieValue(value = "myCookie", required = false) String cookie //특정 쿠키를 조회한다.
) {}
{% endhighlight %}  
파라미터와 어노테이션을 통해 헤더의 모든 정보를 쉽게 가져올 수 있는 것을 볼 수 있다.  

# HTTP 요청  
맵핑, 헤더 조회에 대해 알아봤으니 이제 HTTP 요청에서 보내는 진짜 데이터를 조회하는 방법을 알아보자.  
이전에 배웠듯이 HTTP 요청이 서버에 데이터를 전달하는 방식은 크게 세 가지로 나눌 수 있다.  

- **GET - 쿼리 파라미터**  
- **POST - HTML Form**  
- **HTTP message body**  
위의 두 가지는 똑같이 쿼리 파라미터를 사용하므로 같은 방법으로 조회할 수 있다.  

## 쿼리 파라미터 조회  
서블렛을 통해서도 조회가 가능했지만, 이제 스프링 MVC의 **@RequestParam** 어노테이션을 사용하면 손쉽게 조회가 가능하다.  
{% highlight java %}
@RequestMapping("/headers")
public String requestParamV2(
    @RequestParam("username") String memberName,
    @RequestParam("age") int memberAge) {}  

@RequestMapping("/request-param-v3")
public String requestParamV3(
    @RequestParam(required = true, defaultValue = "guest") String username,
    @RequestParam(required = false, defaultValue = "-1") int age) {}

@RequestMapping("/request-param-map")
public String requestParamMap(@RequestParam Map<String, Object> paramMap) {}
{% endhighlight %}  
파라미터의 이름을 @RequestParam의 매개변수로 넣어주면 value를 파라미터로 반환해준다. 또한 아래와 같이 쿼리 파라미터의 이름과 변수 이름이 같다면 어노테이션의 매개변수를 생략하는 것도 가능하다.  
primitive 타입이라면 아예 어노테이션 자체도 생략이 가능하지만 가독성이 불분명해지므로 지양하자.  
또한 어노테이션의 매개변수로 필수값인지를 나타내는 **required**, 기본 값을 나타내는 **defaultValue**를 설정해줄 수도 있다.
위에서 헤더를 모두 조회할 때 사용했던 MultiValueMap 또는 Map을 이용하여 파라미터 값을 모두 조회하여 Map으로 받아올 수도 있다.  

## 파라미터를 통한 객체 생성  
원래는 쿼리 파라미터를 받아와서 내가 필요한 객체에 값을 직접 입력하여 생성해줘야 했다. 하지만 이젠 스프링 MVC의 **@ModelAttribute** 어노테이션이 해당 기능을 자동화하여 수행한다.  

{% highlight java %}
package hello.springmvc.basic;
import lombok.Data;
@Data
public class HelloData {
    private String username;
    private int age;
}
{% endhighlight %}  
먼저 파라미터 데이터를 넣어서 만들어줄 객체의 코드이다. 이전과 같이 username과 age가 있다.  


