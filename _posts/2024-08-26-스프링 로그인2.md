---
title: "스프링 MVC-스프링 로그인-필터와 인터셉터"
layout: post
date: 2024-08-26 16:43
tag:
- Spring
- JAVA
description: 스프링 입문 강의 핵심 정리
---  

# 공통 관심 사항  
이전 포스팅의 페이지 요구사항을 보면, 로그인 하지 않은 사용자는 상품 관리 페이지에 접근이 불가능해야 한다.  
하지만 현재의 페이지에서는 접근하는 버튼은 없지만, url을 직접 입력하면 접근이 가능하다.  
로그인 여부를 페이지에 접근할 때 체크하면 구현할 수 있겠지만, 이렇게 하면 관련된 모든 로직에서 로그인 여부를 일일이 체크헤야 하고, 로그인 관련 로직이 변경되면 모든 로직을 일일이 수정해 주어야 한다.  
이렇게 핵심 비즈니스 로직이 아니면서 여기저기서 쓰이는 **공통 관심 사항**은 스프링의 AOP로 처리가 가능하지만, 웹에 관련된 공통 관심사항은 **서블릿 필터**, 또는 **스프링 인터셉터**를 사용하는 것이 좋다.  
왜냐하면 웹과 관련된 공통 관심사를 처리하기 위해선 HttpServletRequest 등을 매개변수로 받아야 하는데, 필터와 인터셉터에선 기본적으로 제공하기 때문이다.  

기본적으로 필터와 인터셉터는 다음과 같은 순서로 작동한다.  

HTTP 요청 -> WAS -> **필터** -> 서블릿(Dispatcher Servler 포함) -> 스프링 인터셉터 -> 컨트롤러 -> 스프링 인터셉터(afterCompletion 등)

# 서블릿 필터  
**서블릿 필터**는 기본적으로 **인터페이스**이다. **Filter** 인터페이스를 구현하여 사용하는데, 아래와 같이 이루어져 있다.  

{% highlight java %}  
public interface Filter {
    public default void init(FilterConfig filterConfig) throws ServletException {}

    public void doFilter(ServletRequest request, ServletResponse response,FilterChain chain) throws IOException, ServletException;

    public default void destroy() {}
}
{% endhighlight %}  

**init()**은 필터 초기화 메서드로 컨테이너가 생성될 때 실행된다.  
**doFilter()**는 고객의 요청이 올 때 실행되는 메서드로, 필터에 원하는 로직들은 여기에 들어간다.  
**destroy()**는 필터 종료 메서드로 컨테이너가 종료될 때 실행된다.  
서블릿 필터는 체인으로 구성되고, 체인들의 순서 사이에 필터를 자유롭게 추가할 수 있다.  

이렇게 구현한 Filter는 **FilterRegistrationBean** 객체에서 등록하여 사용할 수 있다.  

# 인증 필터  
로그 필터를 작성하는 과정은 중복이 많으니 스킵하고, 우리가 페이지에 사용할 인증 필터를 서블릿 필터를 통해 만들어보자.  

{% highlight java %}  
@Slf4j
public class LoginCheckFilter implements Filter {
    static final String[] whitelist = {"/", "/members/add", "/login", "/logout", "/css/*"};
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest httpRequest = (HttpServletRequest) servletRequest;
        String requestURI = httpRequest.getRequestURI();
        HttpServletResponse httpResponse = (HttpServletResponse) servletResponse;

        try{
            log.info("인증 체크 필터 시작{}", requestURI);
            if(isLoginCheckPath(requestURI)) {
                log.info("인증 체크 로직 실행 {}", requestURI);
                HttpSession session = httpRequest.getSession(false);
                if(session==null || session.getAttribute(SessionConst.LOGIN_MEMBER)==null) {
                    log.info("미인증 사용자 요청 {}", requestURI);
                    httpResponse.sendRedirect("/login?redirectURL=" + requestURI);
                    return;
                }
            }
            filterChain.doFilter(servletRequest, servletResponse);
        } catch(Exception e) {
            throw e;
        } finally {
            log.info("인증 체크 필터 종료 {}", requestURI);
        }
    }

    boolean isLoginCheckPath(String requestURI) {
        return !PatternMatchUtils.simpleMatch(whitelist, requestURI);
    }
}
{% endhighlight %}  

init()과 destroy()는 default 메서드이므로 의무적으로 구현하지 않아도 된다.  
Filter에서 제공하는 **ServletRequest**는 우리가 사용하던 HttpServletRequest의 부모이므로 캐스팅을 해주어야 한다.  

먼저 로그인 하지 않아도 접근할 수 있는 url들을 화이트리스트로 배열에 미리 등록해두고, 해당 url들이 아닌 url에 접근했다면 로직을 실행한다.  
세션을 받아와 로그인 되어있는 상태인지 체크한 후 되어있다면 넘어가고, 로그인이 되어있지 않다면 로그인 화면으로 리다이렉트 시키고 필터가 종료된다.  

{% highlight java %}  
@Bean
public FilterRegistrationBean loginCheckFilter() {
    FilterRegistrationBean<Filter> filterRegistrationBean = new FilterRegistrationBean<>();
    filterRegistrationBean.setFilter(new LoginCheckFilter());
    filterRegistrationBean.setOrder(2);
    filterRegistrationBean.addUrlPatterns("/*");
    return filterRegistrationBean;
}
{% endhighlight %}  
기존의 로그 필터가 order 1이므로 2로 해주어 등록해준다. addUrlPatterns()에 "/*"로 매개변수를 넣으면 모든 url을 대상으로 적용된다.

