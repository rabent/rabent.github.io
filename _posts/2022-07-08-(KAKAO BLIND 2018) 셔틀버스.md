---
title: "(2018 KAKAO BLIND) 셔틀버스"
layout: post
date: 2022-07-08 14:40
tag:
- KAKAO
- 코테
- c++
description: 카카오 블라인드 2018 코딩테스트 문제
---

# 문제 설명

카카오에서는 무료 셔틀버스를 운행하기 때문에 판교역에서 편하게 사무실로 올 수 있다. 카카오의 직원은 서로를 '크루'라고 부르는데, 아침마다 많은 크루들이 이 셔틀을 이용하여 출근한다.

이 문제에서는 편의를 위해 셔틀은 다음과 같은 규칙으로 운행한다고 가정하자.

+ 셔틀은 09:00부터 총 n회 t분 간격으로 역에 도착하며, 하나의 셔틀에는 최대 m명의 승객이 탈 수 있다.
+ 셔틀은 도착했을 때 도착한 순간에 대기열에 선 크루까지 포함해서 대기 순서대로 태우고 바로 출발한다. 예를 들어 09:00에 도착한 셔틀은 자리가 있다면 09:00에 줄을 선 크루도 탈 수 있다.

일찍 나와서 셔틀을 기다리는 것이 귀찮았던 콘은, 일주일간의 집요한 관찰 끝에 어떤 크루가 몇 시에 셔틀 대기열에 도착하는지 알아냈다. 콘이 셔틀을 타고 사무실로 갈 수 있는 도착 시각 중 제일 늦은 시각을 구하여라.

단, 콘은 게으르기 때문에 같은 시각에 도착한 크루 중 대기열에서 제일 뒤에 선다. 또한, 모든 크루는 잠을 자야 하므로 23:59에 집에 돌아간다. 따라서 어떤 크루도 다음날 셔틀을 타는 일은 없다.

## 입력 형식

셔틀 운행 횟수 n, 셔틀 운행 간격 t, 한 셔틀에 탈 수 있는 최대 크루 수 m, 크루가 대기열에 도착하는 시각을 모은 배열 timetable이 입력으로 주어진다.

+ 0 ＜ n ≦ 10
+ 0 ＜ t ≦ 60
+ 0 ＜ m ≦ 45
+ timetable은 최소 길이 1이고 최대 길이 2000인 배열로, 하루 동안 크루가 대기열에 도착하는 시각이 HH:MM 형식으로 이루어져 있다.
+ 크루의 도착 시각 HH:MM은 00:01에서 23:59 사이이다.

## 출력 형식

콘이 무사히 셔틀을 타고 사무실로 갈 수 있는 제일 늦은 도착 시각을 출력한다. 도착 시각은 HH:MM 형식이며, 00:00에서 23:59 사이의 값이 될 수 있다.

## 입출력 예제

n	| t	| m	| timetable	| answer
--- | --- | --- | --- | ---
1	| 1	| 5	| ["08:00", "08:01", "08:02", "08:03"]	| "09:00"
2	| 10	| 2	| ["09:10", "09:09", "08:00"]	| "09:09"
2	| 1	| 2	| ["09:00", "09:00", "09:00", "09:00"]	| "08:59"
1	| 1	| 5	| ["00:01", "00:01", "00:01", "00:01", "00:01"]	| "00:00"
1	| 1	| 1	| ["23:59"]	| "09:00"
10	| 60	| 45	| ["23:59","23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59", "23:59"]	| "18:00"

# 문제 풀이
잘 생각해보면 간단한 자료구조 문제이다. 비문학 지문같은 문제를 정확히 해석하고 콘이 셔틀을 타는 시간은 막차 시간에 자리가 있을 시에는 막차가 온 시간, 자리가 없을 경우에는 누구 한명의 자리를 뺏어야하므로 마지막에 탄 사람의 탑승시각-1분임을 떠올려낸다면 이후 구현 자체는 크게 문제될 것이 없었다.

# 코드
{% highlight c++ %}
#include <string>
#include <vector>
#include <queue>
#include <algorithm>

using namespace std;

queue<int> q; //탑승 시각을 먼저 온 순으로 넣어줄 queue
int cur=540; //첫 차는 09:00에 오므로 분으로 치환한 540을 넣어준다

string solution(int n, int t, int m, vector<string> timetable) {
    string answer = ""; sort(timetable.begin(), timetable.end()); int ans=0;
    for(string s : timetable) { //분으로 치환하여 queue에 넣어준다
        string h=s.substr(0,2); string m=s.substr(3,2);
        int a=stoi(h); int b=stoi(m);
        int time=a*60+b; q.push(time);
    }
    for(int i=0; i<n; i++) {
        int count=0; int last;
        for(int j=0; j<m; j++) {
            if(q.front()<=cur && !q.empty()) { last=q.front();
                q.pop(); count++;} //현재 시각보다 먼저 온 사람을 태우고
                //마지막으로 탄 사람을 기록한다
        }
        if(i==n-1) {//막차일때
            if(count<m) {//자리가 남아있다면 answer은 현재 시각
                ans=cur;
            }
            else if(count==m) {//자리가 없다면 마지막으로 탄 사람의 탑승시각-1
                ans=last-1;
            }
        }
        cur+=t;
    }
    int a=ans/60; int b=ans%60;
    string hour=to_string(a); string min=to_string(b);
    if(hour.size()==1) hour="0"+hour;
    if(min.size()==1) min="0"+min;
    answer=hour+":"+min;
    return answer;
}
{% endhighlight %}