---
title: "스프링 MVC-스프링 API 예외처리"
layout: post
date: 2024-09-02 17:00
tag:
- Spring
- JAVA
description: 스프링 입문 강의 핵심 정리
---  

# API 예외  
웹에서의 예외 처리는 간단했다. 각 오류 코드에 맞춰 오류 페이지를 웹에 띄우기만 하면 끝이었다.  
하지만 API의 경우는 얘기가 달라진다. API에 따라 오류 응답의 스펙도 다르고, JSON으로의 형식 변환도 필요하다.  
또한 컨트롤러에 따라서 주문에서 터진 예외와 등록에서 터진 예외가 다르게 처리되어야 하는 경우도 있다.  
스프링에서 이러한 API 예외를 어떻게 처리하는지에 대해 알아보자.  

# API 예외 처리  
아무런 예외 처리 없이 기본 값으로 API에 응답하면 예외 발생 시에 JSON이 아닌 **html 형식으로 응답**이 나간다. 클라이언트는 정상응답이든 예외던 JSON 형식으로 받기를 바라므로 이 부분을 처리해야 한다.  

가장 먼저 원시적인 방법으로는 이전 포스팅에서 사용했던 **오류 페이지 컨트롤러를 JSON을 반환하도록 수정**하는 것이다.  

{% highlight java %}  
    @RequestMapping(value = "/error-page/500",produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<Map<String, Object>> errorPage500Api(
            HttpServletRequest request, HttpServletResponse response) {
        log.info("api 에러페이지 500");
        Map<String,Object> result=new HashMap<>();
        Exception ex = (Exception) request.getAttribute(ERROR_EXCEPTION);
        result.put("status", request.getAttribute(ERROR_STATUS_CODE));
        result.put("message",ex.getMessage());
        Integer statusCode = (Integer) request.getAttribute(ERROR_STATUS_CODE);
        return new ResponseEntity<>(result, HttpStatus.valueOf(statusCode));
    }
{% endhighlight %}  

@RequestMapping에서 매개변수를 추가로 넣어 Http 헤더의 Accept가 application/json일 때에는 그에 맞게 json으로 변환된 값을 반환하도록 할 수 있다.  

이전 포스팅에서 사용하던 **BasicErrorController를 확장하여 처리**할 수도 있다.  

{% highlight java %}  
    @RequestMapping(produces = MediaType.TEXT_HTML_VALUE)
    public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) {}

    @RequestMapping
    public ResponseEntity<Map<String, Object>> error(HttpServletRequest request) {}
{% endhighlight %}  

위 코드와 같이 BasicErrorController는 Http 헤더의 Accept가 text/html이면 view를 반환하고 그 외의 경우에는 ResponseEntity로 JSON 형식을 반환하는 로직이 이미 존재한다.  
따라서 위의 코드를 확장하고 application.properties에서 설정을 통해 API 예외 처리가 가능하지만, 더 나은 방법이 존재하므로 거의 사용되지 않는다.  

# ExceptionHandler  
스프링 MVC는 WAS까지 예외가 전달되기 전에 예외를 처리할 수 있는 **ExceptionResolver**를 제공한다.  
작동 순서는 다음과 같다.  

![ExceptionHandler](/assets/img/ExceptionHandler%20작동.png)  

ExceptionHandler에서 예외를 잡아 처리했다면 WAS에는 정상 응답이 전달된다.  
이 ExceptionHandler를 어떻게 사용하는지 알아보자.  

{% highlight java %}  
public interface HandlerExceptionResolver {
    ModelAndView resolveException(
    HttpServletRequest request, HttpServletResponse response,
    Object handler, Exception ex);
}
{% endhighlight %}  

ExceptionHandler는 정확히는 **HandlerExceptionHandler**로 인터페이스를 구현하여 사용한다. 

{% highlight java %}  
@Slf4j
public class MyHandlerExceptionResolver implements HandlerExceptionResolver {
    @Override
    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
        try {
            if (ex instanceof IllegalArgumentException) {
                log.info("IllegalArgumentException resolver to 400");
                response.sendError(HttpServletResponse.SC_BAD_REQUEST, ex.getMessage());
                return new ModelAndView();
            }
        } catch (IOException e) {
            log.error("resolver ex", e);
        }
        return null;
    }
}
{% endhighlight %}  

기본적으로 서버 내에서 어떠한 예외가 발생하면 Internal Server Error 이므로 **코드 500을 반환**한다.  
예외에 따라 다른 코드를 반환하길 원하여 ExceptionHandler를 구현하여 만든 코드로 IllegalArgumentException이 발생하면 에러코드를 400으로 바꿔 전달하도록 구현하였다.  
ExceptionHandler의 반환값에 따른 작동 방식은 다음과 같다.  

- **빈 ModelAndView**: new ModelAndView() 처럼 빈 ModelAndView 를 반환하면 뷰를 렌더링 하지 않고, 정상 흐름으로 서블릿이 리턴된다.  
- **ModelAndView 지정**: ModelAndView 에 View , Model 등의 정보를 지정해서 반환하면 뷰를 렌더링 한다.  
- **null**: null 을 반환하면, 다음 ExceptionResolver 를 찾아서 실행한다. 만약 처리할 수 있는 ExceptionResolver 가 없으면 예외 처리가 안되고, 기존에 발생한 예외를 서블릿 밖으로 던진다.  

위 코드에서는 빈 ModelAndView를 반환했으므로 정상적으로 WAS가 response.sendError(400)을 받고 400코드 에러가 발생한 것과 같이 동작할 것이다.  

ExceptionResolver를 활용하면 위와 같이 에러코드를 변경하는 것 뿐만 아니라 바로 **뷰 템플릿을 반환하여 오류 처리를 끝낼 수도** 있고 response.getWriter()를 통해 **json 값을 반환**할 수도 있다.