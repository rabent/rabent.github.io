---
title: "Android 보드게임 Oh-Mok!"
layout: post
date: 2023-02-14 16:29
tag:
- game
- 프로젝트
- c#
- unity
description: 첫 프로젝트 'Oh-Mok!' 리뷰
---

# Repository & Download

[github](https://github.com/nilbace/Oh-MOK)
[play store link]()

# 게임 특징

+ Unity
+ Android
+ Photon
+ 전략 보드게임
+ 서브 프로그래머
+ 기획자 3, 프로그래머 3, 그래픽 2, 사운드 1
+ Google play store 출시

# 설명

프로젝트의 서브 프로그래머로써 참여하여 유니티의 파티클 시스템을 사용한 effect 제작, Dotween 에셋을 사용한 간단한 카드 뒤집기, 확대 등등의 애니메이션 효과 제작, 각 필요한 파트에 사운드 추가, json을 이용한 유저 데이터 저장, 게임 매니저의 무승부 기능과 타이머 추가, 네트워크 매니저의 두 클라이언트의 카드가 서로 동기화 되는 기능, 무승부 제안이 다른 클라이언트에도 동기화되어 전달되는 기능, 이외 간단한 레이어 조정과 버그 수정 등 여러 파트를 오가며 다양한 업무를 수행하였습니다. 여러 파트를 개발하였고 첫 프로젝트였던 만큼 정말 다 적기 힘들만큼 많은 것을 배울 수 있는 프로젝트였습니다.

## 구현 파트

{% highlight c# %}

void Update() {
        if(timeron) {
            time+=Time.deltaTime; //time이란 int변수에 각 턴의 지나간 시간을 저장
            if(time>=30) {
                if(isMyTurn) endMyTurn(); //시간이 30초를 지나면 (자기턴일때) 턴을 종료
            }
        }
    }

[PunRPC] void startMyTurn()
    {
        isMyTurn = true;
        canuseCard = true;  // 카드를 사용할 수 있게 함
        timeron=true;
        for (int i = 0; i < 81; i++)
        {
            if (gomokuData[i] == 0)   // 아직 돌을 두지 않은 부분만 클릭할 수 있게 함
                gomokuTable[i].interactable = true;
        }
        PV.RPC("timermake", RpcTarget.AllBuffered); //두 클라이언트 양쪽에 모두 'timermake' 함수를 실행시킴
        NetWorkManager.instance.printScreenString("나의 턴");  // '나의 턴' 출력
    }

[PunRPC] void timermake() {
    if(timerins!=null) Destroy(timerins); //만약 타이머가 이미 있다면 파괴함
    if(isMyTurn) {
        timerins=Instantiate(timer, new Vector3(-150,-550,10), Quaternion.identity); // 자기쪽 위치
        timerins.transform.SetParent(this.transform.parent.transform,false); //timer는 unity UI의 fill image 기능을 사용하기에 캔버스 내부 오브젝트의 자식으로 만들어줌
    }
    else {
        timerins=Instantiate(timer, new Vector3(-400,830,10), Quaternion.identity); //상대쪽 위치
        timerins.transform.SetParent(this.transform.parent.transform,false);
    }
    time=0; //시간 초기화
}

{% endhighlight %}

![timer.gif](/assets/img/timer.gif)

> Unity UI의 fill image 기능을 사용하여 시계바늘이 회전하여 지나간 자리는 빨간색으로 채워주는 타이머를 구현하여 각 턴의 제한시간을 볼 수 있게 하였습니다. (녹화 프로그램 상의 문제로 빨간색이 깨져나옴) 기획 쪽의 의견으로 타이머의 위치를 자신의 턴일 때는 자신 캐릭터 옆에, 상대 턴일땐 상대 캐릭터 옆에 생성시키도록 하였습니다.

{% highlight c# %}
void dolmove(Image img) { //돌 5개가 모이면 가운데 돌로 돌들이 이동하는 애니메이션
    Vector3 tmp=img.transform.position;
    Sequence seq=DOTween.Sequence();
    seq.Join(img.transform.DOMove(charging.center,0.75f));
    seq.Join(img.transform.DOScale(new Vector3(0,0,0),3f));
    seq.Join(img.DOFade(0, 2f).SetEase(Ease.InQuad));
    seq.Append(img.transform.DOMove(tmp,0));
    seq.Join(img.transform.DOScale(new Vector3(1,1,1),0));
}


if(PhotonNetwork.IsMasterClient)  // 검은 돌이 오목을 완성한 경우. 내가 MasterClient이면 내가 검은 돌을 두는 사람이므로 내가 공격에 성공한 것임 → 상대방 HP를 깎음
    {
        StartCoroutine(enemyshoot()); //충돌 시 폭발하는 파티클 투사체를 상대 캐릭터를 향해 발사함
        PlayerManager.enemyPlayerManager.GetDamaged();
    }
    else
    {
        StartCoroutine(myshoot()); //투사체를 내 캐릭터를 향해 발사함
        PlayerManager.myPlayerManager.GetDamaged();
    }
{% endhighlight %}

![particle.gif](/assets/img/part.gif)

> unity 엔진의 particle system을 사용하여 돌 5개(오목)가 발생 시 각 돌의 위치에서 가운데 돌을 향해 광선을 발사하는 효과, 그 이후 가운데 돌에서 캐릭터를 향해 투사체를 발사하여 캐릭터와 충돌 시 폭발하는 효과를 제작하였습니다.
그리고 Dotween 에셋을 사용하여 각 돌들이 가운데 돌을 향해 모이는 애니메이션을 제작했습니다.

{% highlight c# %}

    public void setmaster(float sliderval) {
        audiomixer.SetFloat("Master", Mathf.Log10(sliderval)*20);
        playerData.mastervol=sliderval;
        SavePlayerDataToJson();
    }

    public void setbgm(float sliderval) {
        audiomixer.SetFloat("BGM", Mathf.Log10(sliderval)*20);
        playerData.bgmvol=sliderval;
        SavePlayerDataToJson();
    }
    public void setsfx(float sliderval) {
        audiomixer.SetFloat("SFX", Mathf.Log10(sliderval)*20);
        playerData.sfxvol=sliderval;
        SavePlayerDataToJson();
    }

{% endhighlight %}

> 각 사운드의 볼륨을 설정 창의 슬라이더와 연결하여 json 파일의 유저 데이터에 저장하는 함수를 제작했습니다.

{% highlight c# %}

    public void draw() 
    {
        PlayerManager.myPlayerManager.character_img.GetComponent<SpriteRenderer>().sprite=PlayerManager.myPlayerManager.drawimg; //캐릭터 초상화를 화해제안 이미지로 교체
        PlayerManager.myPlayerManager.character_img.GetComponent<SpriteRenderer>().transform.localScale=new Vector3(0.15f,0.15f,0.15f);
        PlayerManager.myPlayerManager.drawready=true;
        this.gameObject.GetComponent<AudioSource>().Play(); //화해제안 효과음을 play
        PV.RPC("drawsyncro", RpcTarget.OthersBuffered);
        if(PlayerManager.myPlayerManager.drawready==true && PlayerManager.enemyPlayerManager.drawready==true) {
            GameManager.instance.draw();
            PV.RPC("drawstop", RpcTarget.AllBuffered); //양쪽 모두 화해 버튼을 눌렀을 시 게임을 종료하고 무승부 결과창을 띄움
        }    
    }

    [PunRPC] void drawsyncro() { //상대 클라이언트에 내 클라이언트에서 화해 버튼을 누른 결과를 동기화하는 함수
        this.gameObject.GetComponent<AudioSource>().Play();
        PlayerManager.enemyPlayerManager.character_img.GetComponent<SpriteRenderer>().sprite=PlayerManager.enemyPlayerManager.drawimg;
        PlayerManager.enemyPlayerManager.character_img.GetComponent<SpriteRenderer>().transform.localScale=new Vector3(0.15f,0.15f,0.15f);
        PlayerManager.enemyPlayerManager.drawready=true;
    }

{% endhighlight %}

![draw.gif](/assets/img/draw.gif)

> 마법학교의 학생들끼리 오목을 둔다는 설정에 따라 게임 도중 화해 버튼을 누르면 상대에게 캐릭터 초상화가 화해 이미지로 바뀌고 화해제안 효과음을 재생하는 기능을 구현하였습니다. 양쪽 다 화해 제안에 응할 시에는 게임은 무승부로 종료됩니다.