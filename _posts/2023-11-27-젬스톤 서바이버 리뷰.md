---
title: "(2020 KAKAO BLIND) 블록 이동하기"
layout: post
date: 2023-08-15 20:54
tag:
- KAKAO
- 코테
- c++
description: 카카오 블라인드 2020 코딩테스트 문제
---

# 서문
---
졸업 작품으로써 만들기 시작한 '젬스톤 서바이버'가 드디어 끝이 났다. 학기 시작하기 한참 전에 졸업 프로젝트 주제를 제출해야 하는 것을 모르고있다가 부랴부랴 급하게 제출한 주제가 이 '젬스톤 서바이버'였다. 옛날부터 생각은 해오던 주제지만 이렇게 갑작스럽게 만들게 될 줄은 몰랐었다.  
게임을 메인 프로그래머로써 아무 것도 없는 맨땅에서부터 만드는 것은 처음이고 코딩을 거의 모르는 팀원 한 명과 작업했기 때문에 사실상 1인개발로 제작해야 했는데 필요한 기능부터 하나하나 구현해가며 Bottom-up 방식으로 묶어나가니 어떻게든 게임이 구현이 되었다.  
중간 정리 때부터 시간도 많이 지나고 했으니 게임이 완성된 기념으로 한번 코드 전체를 되돌아보는 시간을 가지고자 글을 작성하게 되었다. 기능 구현에 급급하게 짠 코드라 세련됨이라고는 1도 없고 상당히 지저분하지만 그런 부분을 반성하는 것 또한 글의 의의이니 스크립트를 하나씩 살펴보도록 하겠다.  

# 스크립트
---

<details>
<summary>Gamemanager(클릭 시 접기/펼치기)</summary>
<div markdown="1">

{% highlight c# %}
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;

public class gamemanager : MonoBehaviour
{
    public static gamemanager instance=null;
    public poolmanager poolmng;
    public GameObject inventory;
    public invenmanager invenmanager;
    public playermanager player;
    public Spawner spawner;
    public Slider hpbar;
    public GameObject hp_red;
    public GameObject uimng;
    public uimanager ui;
    public int char_num;
    public float gameTime;
    public bool inv_active=false;
    public TMP_Text min_text;
    public TMP_Text sec_text; 
    public TMP_Text gold_text;
    public TMP_Text kill_text;
    public int gold=0;
    public int kill=0;
    public gemData char1;
    public gemData char2;
    public gemData char3;
    public GameObject game_over_screen;
    public GameObject clear_screen;
    public float maxGameTime = 2 * 10f; // 20�? / 5 * 60f >> 5�?
    public float health;
    public float maxhealth=1000;
    public bool isLive = true;

    void Awake() //게임 초기화 및 ui매니저 데이터 인계받음
    {
        if(instance==null) {
            instance=this;
        }
        else {
            Destroy(this);
        }
        min_text.text="00";
        sec_text.text="00";
        gold_text.text="000";
        uimng=GameObject.Find("UImanager");
        ui=uimng.GetComponent<uimanager>();
        char_num=ui.char_num;
        hp_refresh();
    }

    private void Start() {
        if(char_num==1) {
            GameObject mn=invenmanager.monoliths[0];
            weaponmanager wpmn=mn.GetComponent<weaponmanager>();
            wpmn.gems[0]=char1;
            wpmn.mono_slots[0].g=char1;
            wpmn.monolith_active();
        }
        else if(char_num==2) {
            GameObject mn=invenmanager.monoliths[0];
            weaponmanager wpmn=mn.GetComponent<weaponmanager>();
            wpmn.gems[0]=char2;
            wpmn.mono_slots[0].g=char2;
            wpmn.monolith_active();
            player.char_select2();
        }
        else if(char_num==3) {
            GameObject mn=invenmanager.monoliths[0];
            weaponmanager wpmn=mn.GetComponent<weaponmanager>();
            wpmn.gems[0]=char3;
            wpmn.mono_slots[0].g=char3;
            wpmn.monolith_active();
            player.char_select3();
        }
    }

    public void hp_refresh() {
        hpbar.value=health/maxhealth;
        if(hpbar.value==0) hp_red.SetActive(false);
    }
    

    private void Update()
    {
        gameTime += Time.deltaTime;

        //if(gameTime > maxGameTime){
           // gameTime = maxGameTime;
        //}

        int min=(int)gameTime / 60;
        int sec=((int)gameTime - min*60) % 60;

        if(sec>=60) {
            sec-=60;
        }
        if(min<10) min_text.text="0"+min.ToString();
        else min_text.text=min.ToString();

        if(sec<10) sec_text.text="0"+sec.ToString();
        else sec_text.text=sec.ToString();

        if(gold<10) gold_text.text="00"+gold.ToString();
        else if(gold<100) gold_text.text="0"+gold.ToString();
        else gold_text.text=gold.ToString();

        if(Input.GetKeyDown(KeyCode.I)) { //인벤토리 오픈 및 초기화
            inventory.SetActive(true);
            invenmanager.slot_refresh();
            hpbar.gameObject.SetActive(false);
            Time.timeScale=0;
            inv_active=true;
        }

        if(inv_active==true && Input.GetKeyDown(KeyCode.Escape)) {//인벤토리 켜져있을시 닫고 인벤이 꺼져있으면 설정창을 on
            GameObject[] monoliths=invenmanager.monoliths;
            foreach(GameObject mono in monoliths) {
                mono.GetComponent<weaponmanager>().monolith_active();
            }
            inventory.SetActive(false);
            hpbar.gameObject.SetActive(true);
            inv_active=false;
            Time.timeScale=1;
        }
    }

    public void merchant_phase() { //게임 시작 후 일정시간이 지나면 상점 페이즈를 오픈, 시간을 정지함
    //그와 동시에 현재 스테이지에 있던 모든 오브젝트를 비활성화함으로써 초기화
        foreach(List<GameObject> pool in poolmng.pools) {
            foreach(GameObject obj in pool) {
                obj.SetActive(false);
            }
        }
        spawner.stage++;
        spawner.boss_spawned=false;
        gameTime=0;
        Time.timeScale=0;
        ui.merchant_on();
    }

    public void game_over() {
        game_over_screen.SetActive(true);
        StartCoroutine(game_over_back());
    }

    public void game_clear() {
        clear_screen.SetActive(true);
        kill_text.text=kill.ToString();
        StartCoroutine(game_over_back());
    }

    IEnumerator game_over_back() {
        yield return new WaitForSeconds(4f);
        SceneManager.LoadScene("starting scene");
    }

}
{% endhighlight %}

</div>
</details>

게임 전체를 총괄하는 게임 매니저이다. 게임의 여러 요소를 게임을 시작할 때, 그리고 게임의 스테이지가 넘어갈 때에 초기화해주는 역할도 하기 때문에 변수가 엄청나게 많은 것을 확인할 수 있다.  
게임매니저는 게임 내에서 시간과 캐릭터의 체력을 관리하고 스테이지가 넘어가는 페이즈, 게임오버, 게임 클리어 페이즈를 발동시키는 역할도 한다. 그러면서 자연스럽게 UI매니저의 역할도 겸하게 되는데 처음에는 억지로 UI와 관련된 파트는 전부 따로 제작한 UI매니저에 분담해주려고 했으나 지금와서 보면 오히려 인게임의 UI는 게임 매니저에서 관리하는 것이 훨씬 자연스럽고 코드도 지저분하지 않으며 더 편한 것 같다. 

---  

<details>
<summary>UImanager(클릭 시 접기/펼치기)</summary>
<div markdown="1">

{% highlight c# %}
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;

public class uimanager : MonoBehaviour
{
    public static uimanager ui_instance=null;
    public GameObject startpannnel;
    public GameObject characterpannel;
    public GameObject charremindpannel;
    public GameObject quitremindpannel;
    public GameObject ingame_option;
    public GameObject merchant_pannel;
    public GameObject tuto_pannel;
    public GameObject main_option;
    bool in_game=false;
    public bool pause=false;
    Button fsbtn;
    Button wsbtn;
    Button backbtn;
    public int char_num;
   
   private void Awake() {
    if(ui_instance==null) {
            ui_instance=this;
            DontDestroyOnLoad(this.gameObject);
        }
    else {
        Destroy(ui_instance.gameObject);
        ui_instance=this;
        DontDestroyOnLoad(this.gameObject);
    }
   }
   public void startbutton() {
    startpannnel.SetActive(false);
    characterpannel.SetActive(true);
   }

   public void main_option_button() {
    main_option.SetActive(true);
   }
   public void main_option_back() {
    main_option.SetActive(false);
   }

   public void tuto_button() {
    tuto_pannel.SetActive(true);
   }
   public void tuto_back_button() {
    tuto_pannel.SetActive(false);
   }
   public void characterselect1() {
    char_num=1;
    charremindpannel.SetActive(true);
   }

   public void characterselect2() {
    char_num=2;
    charremindpannel.SetActive(true);
   }

   public void characterselect3() {
    char_num=3;
    charremindpannel.SetActive(true);
   }

   public void characteryes() {
    characterpannel.SetActive(false);
    startpannnel=null;
    characterpannel=null;
    charremindpannel=null;
    quitremindpannel=null;
    SceneManager.LoadScene("in-game");
    in_game=true;
   }

   public void back_to_main() {
    Time.timeScale=1;
    SceneManager.LoadScene("starting scene");
   }

   public void characterno() {
    char_num=0;
    charremindpannel.SetActive(false);
   }

   public void backtomain() {
    characterpannel.SetActive(false);
    startpannnel.SetActive(true);
   }

   public void exit_button() {
    quitremindpannel.SetActive(true);
   }

   public void exit_yes() {
    Debug.Log("exited");
    Application.Quit();
   }

   public void exit_no() {
    quitremindpannel.SetActive(false);
   }

   public void full_screen() {
    Screen.sleepTimeout = SleepTimeout.NeverSleep;
    Screen.SetResolution(1920, 1080, true);
    Debug.Log("full screen");
   }

   public void window_screen() {
    Screen.sleepTimeout = SleepTimeout.NeverSleep;
    Screen.SetResolution(1280, 720, false);
    Debug.Log("windowed");
   }

   public void merchant_on() {
    merchant_pannel=GameObject.Find("Canvas").transform.Find("merchant pannel").gameObject;
    merchant_pannel.SetActive(true);
    Time.timeScale=0;
   }

   private void Update() {
    if(in_game==true && gamemanager.instance!=null) {
        //인벤토리가 꺼져있을때 esc를 누르면 인게임 옵션 패널을 띄워줌
        if(pause==true && Input.GetKeyDown(KeyCode.Escape)) {
            ingame_option.SetActive(false);
            pause=false;
            Time.timeScale=1;
        }
        else if(gamemanager.instance.inv_active==false && Input.GetKeyDown(KeyCode.Escape)) {
            ingame_option=GameObject.Find("Canvas").transform.Find("ingame_option pannel").gameObject;
            ingame_option.SetActive(true);
            Time.timeScale=0;
            pause=true;
            fsbtn=GameObject.Find("full screen button").GetComponent<Button>();
            fsbtn.onClick.AddListener(full_screen);
            wsbtn=GameObject.Find("window screen button").GetComponent<Button>();
            wsbtn.onClick.AddListener(window_screen);
            backbtn=GameObject.Find("back button").GetComponent<Button>();
            backbtn.onClick.AddListener(back_to_main);
        }
        
    }
   }
}
{% endhighlight %}

</div>
</details>

메인 화면과 인게임의 여러 UI의 발동을 담당하는 UI매니저이다. 메인화면에서 인게임으로 넘어가는 동안의 캐릭터 선택, 튜토리얼 보기, 옵션창 등의 버튼에 할당되어야 하는 함수들이 있으며 DontDestroyOnLoad를 사용하여 게임이 메인화면 씬에서 인게임 씬으로 넘어가도 파괴되지 않고 인게임의 상점, 인벤토리 등의 UI를 담당하게 된다.  
DontDestroyOnLoad를 사용한 이유는 게임의 기획 상 캐릭터 선택창에서 캐릭터를 선택하면 선택한 캐릭터에 맞는 시작 젬을 인게임에서 가지고 시작해야 하기 때문이다. 따라서 메인화면에서부터 씬을 넘어 인게임으로 어떤 캐릭터를 선택했는지 변수를 전달해주는 부분이 필요했고 DontDestroyOnLoad를 사용하여 해결하였다.  
스크립트가 씬을 넘어감에 따라 인게임 내의 UI도 UI매니저가 전부 담당하면 좋을 것 같아 그렇게 구현하려 했지만 그렇게 하기에는 인게임 내의 꽤 많은 UI를 전부 Find 함수를 사용하여 찾아서 할당해야 했고 이는 굉장히 비효율적으로 보였다. 따라서 같은 기능을 공유하는 옵션창과 몇몇 UI만을 담당하게 되었고 인게임 내의 UI는 게임 매니저가 담당하는 것이 되었다. 지금 보면 이러한 분담이 훨씬 자연스러운 것 같다.

<details>
<summary>Invenmanager(클릭 시 접기/펼치기)</summary>
<div markdown="1">

{% highlight c# %}
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class invenmanager : MonoBehaviour
{
    // Start is called before the first frame update
    public static invenmanager inventory;
    public GameObject inv_pannel;
    public gemData[] gemlist;
    public GameObject[] monoliths;
    public GameObject[] slots;
    public int gemcount=0;


    void Awake()
    {
        if(inventory==null) {
            inventory=this;
        }
        else Destroy(this.gameObject);
    }
   
    public void inven_dead() {
        foreach(GameObject obj in monoliths) {
            weaponmanager wpmn=obj.GetComponent<weaponmanager>();
            wpmn.monolith_clear();
        }
    }

    public void slot_refresh() { // 인벤토리 슬롯을 젬 리스트와 동기화시켜줌
        for(int i=0; i<slots.Length; i++) {
            if(gemlist[i]!=null){
                slots[i].GetComponent<slot>().g=gemlist[i];
            }
            Debug.Log("slot refresh");  
        }
    }

    public void gemlist_refresh() { //인벤토리 내 젬의 위치변경 등이 있을때 리스트에도 반영해줌
        gemcount=0;
        for(int i=0; i<slots.Length; i++) {
            gemlist[i]=slots[i].GetComponent<slot>().g;
            if(gemlist[i]!=null) gemcount++;
        }
        Debug.Log("gemlist refresh");  
    }

    public void add_gem(gemData gd) { //슬롯에 여유가 있다면 젬리스트에 젬 데이터를 넣어줌
        if(gemcount<slots.Length) {
            for(int i=0; i<slots.Length; i++) {
                if(gemlist[i]==null) {
                    gemlist[i]=gd;
                    gemcount++;
                    break;
                }
            }
        }
        else {
            Debug.Log("slot full");
        }
    }

}
{% endhighlight %}

</div>
</details>

게임 내의 인벤토리를 관리하는 인벤토리 매니저이다. 말은 인벤토리 매니저지만 젬의 획득, 인벤토리 갱신 등 간단한 역할을 제외하면 사실상 다른 스크립트들이 인벤토리에 접근할 때 쓸 수 있는 인벤토리 구조체와 같은 역할을 한다.

<details>
<summary>Slot(클릭 시 접기/펼치기)</summary>
<div markdown="1">

{% highlight c# %}
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;
using Unity.VisualScripting;
using TMPro;

public class slot : MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler, IDropHandler, IPointerEnterHandler, IPointerExitHandler, IPointerClickHandler
{
    [SerializeField]
   private gemData pgem;
   public Image slot_img;
   public bool islock=false;
   public bool isfull=false;
   public bool begin_mono=false;
   public int slot_index;
   public GameObject pannel;
   public TMP_Text title;
   public TMP_Text explain;
   public TMP_Text tags;

   public gemData g { //젬 데이터가 있다면 투명화를 해제
    get {return pgem;}
    set {
        pgem=value;
        if(pgem==null) {
            slot_img.color=new Color(1,1,1,0);
            isfull=false;
        }
        else {
            isfull=true;
            slot_img.sprite=g.spr;
            slot_img.color=new Color(1,1,1,1);
        }
        
    }
   }

   void OnDisable() {
    pannel.SetActive(false);
   }

    public void OnPointerClick(PointerEventData eventData) {
        if(eventData.button==PointerEventData.InputButton.Right) {
            if(this.g!=null) {
                g=null;
                gamemanager.instance.gold+=10;
                invenmanager.inventory.gemlist_refresh();
            }
        }
    }

   public void OnPointerEnter(PointerEventData eventData) {
    //마우스 올리면 젬의 정보 패널을 띄움
        if(this.isfull) {
            pannel.SetActive(true);
            title.text=g.gem_name;
            explain.text=g.gem_explain;
            string str="";
            foreach(string s in g.tags) {
                str+=s + ",";
            }
            if(g.ispassive) {
                foreach(string s in g.required_tag) {
                    str+="<color=#800000ff><b>" + s + "</b></color>" + ",";
                }
            }
            str=str.Remove(str.Length - 1, 1);
            this.tags.text=str;
            Debug.Log("mouse enter");
        }
   }

    public void OnPointerExit(PointerEventData eventData) {
        //마우스 뗐을 때 창 사라짐
        if(pannel.activeSelf==true) {
            pannel.SetActive(false);
            Debug.Log("mouse exit");
        }
    }

   
    public void OnBeginDrag(PointerEventData eventData)
    { //슬롯에 젬이 있을시 슬롯을 클릭하면 draggedslot에 그 슬롯의 데이터를 복사해서 넘겨줌
        pannel.SetActive(false);
        if(isfull && !islock) {
            if(this.gameObject.tag=="monoslot") begin_mono=true;
            draggedslot.instance.dragslot=this;
            draggedslot.instance.dragset(slot_img);
            draggedslot.instance.transform.position=eventData.position;
        }
    }

    public void OnDrag(PointerEventData eventData)
    { //마우스 이동에 따라 draggedslot이 이동
        if(isfull && !islock) {
            draggedslot.instance.transform.position=eventData.position;
        }
    }

    public void OnEndDrag(PointerEventData eventData)
    { //드래그가 끝났을 시 처음에 클릭했던 슬롯에서 발동하는 함수
    //드래그의 종착점이 monolith인지, 다른 슬롯인지에 따라서 필요한 절차를 진행
        if(draggedslot.instance.is_monolith==true && draggedslot.instance.is_change==false && !islock) {
            this.g=null;
            invenmanager.inventory.gemlist[slot_index]=null;
            draggedslot.instance.is_monolith=false;
        }
        else if(draggedslot.instance.is_change==true && !islock) {
            Debug.Log(draggedslot.instance.change_gd);
            this.g=draggedslot.instance.change_gd;
            int idx=draggedslot.instance.change_idx;
            if(draggedslot.instance.is_monolith) {
                invenmanager.inventory.gemlist[slot_index]=draggedslot.instance.change_gd;
                draggedslot.instance.is_monolith=false;
            }
            else {
                invenmanager.inventory.gemlist[idx]=this.g;
                if(!begin_mono) invenmanager.inventory.gemlist[slot_index]=draggedslot.instance.change_gd;
            }
            draggedslot.instance.change_gd=null;
            draggedslot.instance.change_idx=-1;
            draggedslot.instance.is_change=false;
        }
        if(begin_mono && !islock) {
             foreach(GameObject mono in invenmanager.inventory.monoliths) {
                mono.GetComponent<weaponmanager>().monolith_reset();
            }
        }
        draggedslot.instance.drag_invisible(0);
        draggedslot.instance.dragslot=null;
        begin_mono=false;
        invenmanager.inventory.gemlist_refresh();
    }

    public void OnDrop(PointerEventData eventData)
    { //enddrag보다 먼저 발동하는 함수로 드래그가 끝난 위치에 있는 슬롯에서 발동
    //드래그가 끝난 위치가 monolith라면 젬데이터를 monolith로 넘겨주고 refresh
    //드래그가 끝난 위치가 다른 슬롯이라면 그 슬롯에 draggedslot의 데이터를 넘기고 슬롯의 데이터를 받아옴
        if(draggedslot.instance.dragslot!=null && this.gameObject.tag=="monoslot" && !islock) {
            if(this.g!=null) {
                draggedslot.instance.change_idx=this.slot_index;
                draggedslot.instance.change_gd=this.g;
                draggedslot.instance.is_change=true;
            }
            this.g=draggedslot.instance.dragslot.g;
            foreach(GameObject mono in invenmanager.inventory.monoliths) {
                mono.GetComponent<weaponmanager>().monolith_reset();
            }
            draggedslot.instance.is_monolith=true;
        }
        else if(draggedslot.instance.dragslot!=null && this.gameObject.tag=="slot" && !islock) {
            draggedslot.instance.change_idx=this.slot_index;
            draggedslot.instance.change_gd=this.g;
            this.g=draggedslot.instance.dragslot.g;
            draggedslot.instance.is_change=true;
        }
    }
}
{% endhighlight %}

</div>
</details>

인벤토리의 실질적인 기능을 담당하는 Slot 스크립트이다. 유니티에서 제공하는 EventSystem과 여러 handler들을 사용하여 드래그를 통한 슬롯 내 데이터의 교환 및 이동, 마우스를 슬롯에 올렸을 때 나타나는 슬롯 내 데이터에 대한 설명 등을 구현하였다. 타 블로그에서 본 방식인데 투명한 draggedslot이란 슬롯을 하나 더 두었다가 드래그 앤 드랍을 할 때 draggedslot에 원래 슬롯의 데이터를 복사해주어 이동시킴으로써 원 데이터에 손상이 가지 않게 하는 방식을 차용하였다.