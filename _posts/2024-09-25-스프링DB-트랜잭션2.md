---
title: "스프링 DB-트랜잭션2"
layout: post
date: 2024-09-25 17:24
tag:
- Spring
- JAVA
description: 스프링 입문 강의 핵심 정리
---  

# 트랜잭션 문제점  
비즈니스 로직을 담당하는 서비스 계층은 가급적 **순수한 자바 코드로만** 이루어져 있는 것이 좋다. 특정 기술에 종속적이게 서비스 코드를 구현하면 후에 DB 종류를 변경한다던지, 기술의 변경이 있을 때 변경의 여파가 서비스 코드까지 미치게 되기 때문이다.  

그런데 우리가 현재 트랜잭션을 적용한 서비스 코드를 보자. 커넥션을 받기 위해서 **JDBC 기술에 의존**하고 있고, 비즈니스 로직을 처리하는 코드보다도 트랜잭션을 처리하기 위한 코드가 더 많다.  
이렇게 되면 향후 JDBC에서 JPA로 변경할 시 서비스 코드까지 모두 변경해야 한다.  
또한 **예외 누수** 문제가 있다. JDBC 기술에서 나오는 SQLException이 서비스 계층으로 전파되고 있다.  
그 외에는 순수 JDBC를 사용함으로써 try, catch 등 반복되는 구문이 많은 문제가 있다.  

이제 이러한 문제들을 스프링의 도움을 받아 하나씩 해결해보자.  

# 트랜잭션 추상화  
같은 트랜잭션이라도 **기술에 따라 쓰는 방법이 다르다**. 우리는 지금 JDBC를 쓰기 때문에 con.setAutoCommit(false) 로 수동 커밋으로 전환하여 트랜잭션을 시작하지만, JPA는 또 형태가 다르다.  
이렇게 되면 JDBC 기술을 사용하다 JPA로 바꾸면 코드를 전부 변경해야 하는데, 이러한 상황을 막기 위해 **트랜잭션 추상화**를 사용한다.  

![트랜잭션 추상화](/assets/img/트랜잭션%20추상화.PNG)  

트랜잭션 추상화는 우리가 DataSource를 통해 커넥션을 얻는 방식을 추상화한 것과 같다. 트랜잭션 기술에 직접 의존하는 것이 아닌, 추상화된 인터페이스에 의존하고 구현체는 기술에 맞게 갈아끼우는 식이다.  

![트랜잭션 추상화2](/assets/img/트랜잭션%20추상화2.PNG)  

우리는 스프링에서 제공하는 트랜잭션 추상화 기술을 사용하면 된다. **PlatformTransactionManager** 인터페이스를 사용하는데 그에 맞는 구현체들도 모두 준비되어 있다.  

{% highlight java %}  
package org.springframework.transaction;  

public interface PlatformTransactionManager extends TransactionManager {
    TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException;
    void commit(TransactionStatus status) throws TransactionException;
    void rollback(TransactionStatus status) throws TransactionException;
}
{% endhighlight %}  

구조는 위 코드와 같은데, **getTransaction()** 메서드로 트랜잭션을 시작하고 **commit()**, **rollback()** 메서드로 각각 커밋과 롤백을 수행한다.  

트랜잭션 매니저는 트랜잭션 추상화 외에도 한 가지 기능을 수행하는데, **리소스 동기화**이다.  
기존에는 파라미터를 통해 커넥션을 전달하는 방식을 사용했는데, 이러면 코드가 지저분해질뿐더러 커넥션을 넘기는 메서드와 커넥션을 넘기지 않는 메서드 두 가지를 만들어야 하는 등의 문제가 발생한다.  

![트랜잭션 동기화](/assets/img/트랜잭션%20동기화.PNG)  

스프링은 **트랜잭션 동기화 매니저**를 제공한다. **ThreadLocal**을 이용하여 커넥션을 동기화해주기 때문에 멀티쓰레드 환경에서도 안전하게 작동한다. 트랜잭션 매니저는 내부에서 이 트랜잭션 동기화 매니저를 사용한다.  
MVC에서 컨트롤러와 뷰 사이를 모델로 중개하던 것을 생각하면 쉽다. 자세한 작동 방식은 다음과 같다.  

1. 트랜잭션을 시작하려면 커넥션이 필요하다. 트랜잭션 매니저는 데이터소스를 통해 커넥션을 만들고 트랜잭션을 시작한다.  
2. 트랜잭션 매니저는 트랜잭션이 시작된 커넥션을 트랜잭션 동기화 매니저에 보관한다.  
3. 리포지토리는 트랜잭션 동기화 매니저에 보관된 커넥션을 꺼내서 사용한다. 따라서 파라미터로 커넥션을 전달하지 않아도 된다.  
4. 트랜잭션이 종료되면 트랜잭션 매니저는 트랜잭션 동기화 매니저에 보관된 커넥션을 통해 트랜잭션을 종료하고, 커넥션도 닫는다.  

이제 서비스 코드에서 사용하는 트랜잭션 매니저와 리포지토리는 트랜잭션 동기화 매니저를 사이에 두고 커넥션을 주고받는다. 파라미터로 직결되어있지 않기 때문에 위에서 설명한 여러 문제점들이 해결된다.  

이 트랜잭션 매니저를 코드에 적용시켜보자.  

{% highlight java %}  
private void close(Connection con, Statement stmt, ResultSet rs) {
    JdbcUtils.closeResultSet(rs);
    JdbcUtils.closeStatement(stmt);
    //주의! 트랜잭션 동기화를 사용하려면 DataSourceUtils를 사용해야 한다.
     DataSourceUtils.releaseConnection(con, dataSource);
}

private Connection getConnection() throws SQLException {
    //주의! 트랜잭션 동기화를 사용하려면 DataSourceUtils를 사용해야 한다.
    Connection con = DataSourceUtils.getConnection(dataSource);
    log.info("get connection={} class={}", con, con.getClass());
    return con;
}
{% endhighlight %}  

기존 연결을 받아오고 닫는 코드가 **DataSourceUtils**의 **getConnection()**, **releaseConnection()**을 사용하도록 변경되었다. 트랜잭션 동기화를 사용하기 위해선 DataSourceUtils를 사용해야 한다.  
**getConnection()**은 트랜잭션 동기화 매니저가 관리하는 커넥션이 **있다면 해당 커넥션을 받아오고**, **없다면 새로운 커넥션을 생성**하여 반환한다. 따라서 트랜잭션과 트랜잭션이 아닌 코드 둘 다 사용이 가능하다.  
**releaseConnection()**은 트랜잭션을 위해 **동기화된 커넥션은 닫지 않고** 유지하고, 트랜잭션 매니저가 관리하는 커넥션이 **아니라면 커넥션을 닫는다**. 이 또한 트랜잭션을 사용하던 안하던 사용이 가능하다.  

리포지토리를 수정했으니 이젠 서비스 코드도 트랜잭션 매니저를 사용하도록 수정하자.  

{% highlight java %}  
private final PlatformTransactionManager transactionManager;

    public void accountTransfer(String fromId, String toId, int money) throws SQLException {
        TransactionStatus status= transactionManager.getTransaction(new DefaultTransactionDefinition());
        try {
            bizLogic(fromId, toId, money);
            transactionManager.commit(status);
        } catch (Exception e) {
            transactionManager.rollback(status);
            throw new IllegalArgumentException(e);
        }
    }
{% endhighlight %}  

트랜잭션 매니저를 외부에서 주입받아 사용하는 코드이다. JDBC를 사용중이므로 DataSourceTransactionManager 구현체를 주입받아야 할 것이다.  
트랜잭션을 시작하고, 커밋 또는 롤백하는 **코드가 굉장히 간결**해졌다. 또한 파라미터를 통해 커넥션을 주고받지 않으므로 이제 서비스 코드에서 **커넥션을 받고 해제하는 코드가 더이상 필요가 없어졌다**.
 

